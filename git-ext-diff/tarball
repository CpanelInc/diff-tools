#!/usr/local/cpanel/3rdparty/bin/perl

use strict;
use warnings;

use Archive::Tar         ();
use Git::Raw::Note       ();
use Git::Raw::Repository ();

my $NOTE_REF = 'refs/notes/ext-diff/tarball';    # Set to undef to disable caching
my $SHOW_TAR = 1;

exit _main(@ARGV) unless caller;

sub _main {
    my ( $old_git_path, $old_file, $old_hex, $old_mode, $new_file, $new_hex, $new_mode, $new_git_path, $git_annotations ) = @_;
    $new_git_path //= $old_git_path;

    my $repo = Git::Raw::Repository->discover('.');

    my $old_tree = _extract_files( $repo, $old_hex, $old_file, $old_git_path );
    my $new_tree = _extract_files( $repo, $new_hex, $new_file, $new_git_path );

    my @options = get_options();
    if ($SHOW_TAR) {
        my $src_prefix = ( map { m/^--src-prefix=(.*)|^--no-prefix()/ ? ($1) : () } @options )[-1] // "a/";
        my $dst_prefix = ( map { m/^--dst-prefix=(.*)|^--no-prefix()/ ? ($1) : () } @options )[-1] // "b/";

        # Check the last color-related command line option or git-config.
        my $no_color;
        if ( my $last_color_option = ( grep { m/^--(?:no-)?color/ } @options )[-1] ) {
            $no_color = $last_color_option =~ m/--no-color|--color=never/;
        }
        else {
            $no_color = system qw(git config --get-colorbool color.diff);
        }
        my $header_color = $no_color ? '' : qx{git config --get-color color.diff.meta bold};

        # TODO: Handle -R switching src-prefix & dst-prefix.
        print_header( "diff --git $src_prefix$old_git_path $dst_prefix$new_git_path", $header_color );
        print_header( $git_annotations, $header_color ) if $git_annotations;
        print "Tarballs $src_prefix$old_git_path and $dst_prefix$new_git_path differ\n";
    }

    exec 'git', 'diff', $old_tree, $new_tree, @options;
    die "Cannot exec: $!";
}

sub print_header {
    my ( $data, $color ) = @_;

    foreach ( split m/\n/, $data ) {
        print $color if $color;
        print $_;
        print "\e[m" if $color;
        print "\n";
    }

    return;
}

sub _extract_files {
    my ( $repo, $id, $tar_file, $git_path ) = @_;

    my $message;
    if ( $id ne '.' && $NOTE_REF ) {
        my $note = Git::Raw::Note->read( $repo, $id, $NOTE_REF );
        $message = $note ? $note->message() : '';
        foreach my $line ( split m/\0/, $message ) {
            my ( $tree, $path ) = split m/ /, $line, 2;
            if ( $path eq $git_path ) {
                return $tree if defined $repo->lookup($tree);

                # Remove the cached entry so it can be replaced with the newly
                # calculated tree.  Since we already need to re-build the tree,
                # there is little cost to update the entry.  And this allows
                # the algorithm to change, since the cache won't be permanent.
                # However, to force a refresh, the dangling tree needs to be
                # pruned with git-gc.
                $message =~ s/(?<=\0)\Q$tree\E [^\0]\0//;
                last;
            }
        }
    }

    # Get a clean index, in memory; modifications to this object will not alter
    # the Git repository because we never write the index to disk.
    my $index = $repo->index();
    $index->clear();

    # Add files to index
    my $iter = Archive::Tar->iter($tar_file);
    while ( my $f = $iter->() ) {
        _handle_file( $index, $f, $git_path );
    }

    # Create root tree
    my $tree = $index->write_tree();

    # Store tree information into note for caching.  We must include the path
    # because the tree will differ based on the path of the tarball and the
    # tarball can be moved or renamed.
    if ( defined $message ) {
        $message .= "$tree $git_path\0";
        Git::Raw::Note->create( $repo, $id, $message, $NOTE_REF, 1 );
    }

    return $tree;
}

sub _handle_file {
    my ( $index, $file, $git_path ) = @_;

    my $full_path = $git_path . '/' . $file->full_path;
    if ( $file->type eq '0' ) {
        my $mode = $file->mode & 0100 ? 0100755 : 0100644;
        $index->add_frombuffer( $full_path, $file->get_content_by_ref, $mode );
    }
    elsif ( $file->type eq '2' ) {
        $index->add_frombuffer( $full_path, $file->linkname, 0120000 );
    }
    elsif ( $file->type ne '5' ) {
        die "Unrecognized type: " . $file->type;
    }

    return;
}

sub get_options {
    my $recognized = qr/
          -U.+
        | --unified=.+

        | --minimal
        | --patience
        | --histogram
        | --diff-algorithm=.*

        | --color(?:=.+)?
        | --no-color
        | --word-diff(?:=.+)?
        | --word-diff-regex=.+
        | --color-words(?:=.+)?

        | --check
        | --ws-error-highlight=.+

        | --full-index
        | --binary
        | --abbrev(?:=.+)?

        | --no-renames
        | -B.*
        | --break-rewrites(?:=.+)?
        | -M.*
        | --find-renames(?:=.+)?
        | -C.*
        | --find-copies(?:=.+)?
        | --find-copies-harder
        | -D
        | --irreversible-delete
        | -l.+

        | -a
        | --text
        | --ignore-space-at-eol
        | -b
        | --ignore-space-change
        | -w
        | --ignore-all-space
        | --ignore-blank-lines

        | --inter-hunk-context=.+
        | -W
        | --function-context

        | --textconv
        | --no-textconv

        | --src-prefix=.*
        | --dst-prefix=.*
        | --no-prefix
    /xs;

    my $PPID = getppid();
    my $file = "/proc/$PPID/cmdline";

    local $/;
    open my $fh, '<', $file or die "Cannot open “$file”: $!";
    my @args = split m/\0/, <$fh>;
    close $fh or warn "Cannot close “$file”: $!";

    return grep { m/^(?:$recognized)$/ } @args;
}
