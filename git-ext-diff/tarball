#!/usr/local/cpanel/3rdparty/bin/perl

# Copyright 2020, cPanel, L.L.C.
# All rights reserved.
# http://cpanel.net
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the owner nor the names of its contributors may be
# used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;

use Archive::Tar         ();
use Getopt::Long         ();
use Git::Raw::Note       ();
use Git::Raw::Repository ();

exit _main(@ARGV) unless caller;

sub _main {
    my @args = @_;

    my %conf = (
        overview  => 1,
        cache_ref => 'refs/notes/ext-diff/tarball',
    );
    Getopt::Long::Parser->new(
        config => [ 'posix_default', 'gnu_compat' ],
    )->getoptionsfromarray(
        \@args,
        'help|?' => \my $print_help,

        'overview!'   => \$conf{overview},
        'cache!'      => \$conf{cache},
        'cache-ref=s' => sub { $conf{cache} = 1; $conf{cache_ref} = "$_[1]" },
    );

    if ($print_help) {
        print_help();
        return 0;
    }

    # Performs exec system call, preventing it from returning.
    _execute_diff_for_git( \%conf, @args );
}

sub _execute_diff_for_git {
    my ( $conf, $old_git_path, $old_file, $old_hex, $old_mode, $new_file, $new_hex, $new_mode, $new_git_path, $git_annotations ) = @_;
    $new_git_path //= $old_git_path;

    my $repo = Git::Raw::Repository->discover('.');

    my $old_tree = _extract_files( $conf, $repo, $old_hex, $old_file, $old_git_path );
    my $new_tree = _extract_files( $conf, $repo, $new_hex, $new_file, $new_git_path );

    my @options = get_git_diff_options();
    my $reverse = ( grep { $_ eq '-R' } @options ) ? 1 : 0;
    ( $old_tree, $new_tree ) = ( $new_tree, $old_tree ) if $reverse;

    if ( $conf->{overview} ) {
        my $src_prefix = ( map { m/^--src-prefix=(.*)|^--no-prefix()/ ? ($1) : () } @options )[-1] // "a/";
        my $dst_prefix = ( map { m/^--dst-prefix=(.*)|^--no-prefix()/ ? ($1) : () } @options )[-1] // "b/";
        ( $src_prefix, $dst_prefix ) = ( $dst_prefix, $src_prefix ) if $reverse;

        # Check the last color-related command line option or git-config.
        my $no_color;
        if ( my $last_color_option = ( grep { m/^--(?:no-)?color/ } @options )[-1] ) {
            $no_color = $last_color_option =~ m/--no-color|--color=never/;
        }
        else {
            $no_color = system qw(git config --get-colorbool color.diff);    # Will check for TTY
        }
        my $header_color = $no_color ? '' : qx{git config --get-color color.diff.meta bold};

        print_header( "diff --git $src_prefix$old_git_path $dst_prefix$new_git_path", $header_color );
        print_header( $git_annotations, $header_color ) if $git_annotations;
        print "Tarballs $src_prefix$old_git_path and $dst_prefix$new_git_path differ\n";
    }

    exec 'git', 'diff', $old_tree, $new_tree, @options;
    die "Cannot exec: $!";
}

sub print_header {
    my ( $data, $color ) = @_;

    foreach ( split m/\n/, $data ) {
        print $color if $color;
        print $_;
        print "\e[m" if $color;
        print "\n";
    }

    return;
}

sub _extract_files {
    my ( $conf, $repo, $id, $tar_file, $git_path ) = @_;
    my $cache_ref = $conf->{cache} ? $conf->{cache_ref} : undef;

    my $message;
    if ( $id ne '0' x 40 && $id ne '.' && $cache_ref ) {
        my $note = Git::Raw::Note->read( $repo, $id, $cache_ref );
        $message = $note ? $note->message() : '';
        foreach my $line ( split m/\0/, $message ) {
            my ( $tree, $path ) = split m/ /, $line, 2;
            if ( $path eq $git_path ) {
                return $tree if defined $repo->lookup($tree);

                # Remove the cached entry so it can be replaced with the newly
                # calculated tree.  Since we already need to re-build the tree,
                # there is little cost to update the entry.  And this allows
                # the algorithm to change, since the cache won't be permanent.
                # However, to force a refresh, the dangling tree needs to be
                # pruned with git-gc.
                $message =~ s/(?<=\0)\Q$tree\E [^\0]\0//;
                last;
            }
        }
    }

    # Get a clean index, in memory; modifications to this object will not alter
    # the Git repository because we never write the index to disk.
    my $index = $repo->index();
    $index->clear();

    # Add files to index
    my $iter = Archive::Tar->iter($tar_file);
    while ( my $f = $iter->() ) {
        _handle_file( $index, $f, $git_path );
    }

    # Create root tree
    my $tree = $index->write_tree();

    # Store tree information into note for caching.  We must include the path
    # because the tree will differ based on the path of the tarball and the
    # tarball can be moved or renamed.
    if ( defined $message ) {
        $message .= "$tree $git_path\0";
        Git::Raw::Note->create( $repo, $id, $message, $cache_ref, 1 );
    }

    return $tree;
}

sub _handle_file {
    my ( $index, $file, $git_path ) = @_;

    my $full_path = $git_path . '/' . $file->full_path;
    if ( $file->type eq '0' ) {
        my $mode = $file->mode & 0100 ? 0100755 : 0100644;
        $index->add_frombuffer( $full_path, $file->get_content_by_ref, $mode );
    }
    elsif ( $file->type eq '2' ) {
        $index->add_frombuffer( $full_path, $file->linkname, 0120000 );
    }
    elsif ( $file->type ne '5' ) {
        die "Unrecognized type: " . $file->type;
    }

    return;
}

# The git-diff options we will propagate.
#
# Some options may be difficult to implement in a well integrated way, and so
# they are excluded (for now).  For example, `-p --raw`, displays all the raw
# output before the diff; to propagate `--raw`, we would have a nested entry
# where raw output suddenly reappears and could cause integration problems.
# The same is true with the `--*stat` family of options.
use constant DIFF_OPTS => qr/
    ^(?:
      -U.+
    | --unified=.+

    | --minimal
    | --patience
    | --histogram
    | --diff-algorithm=.*

    | --color(?:=.+)?
    | --no-color
    | --word-diff(?:=.+)?
    | --word-diff-regex=.+
    | --color-words(?:=.+)?

    | --check
    | --ws-error-highlight=.+

    | --full-index
    | --binary
    | --abbrev(?:=.+)?

    | --no-renames
    | -B.*
    | --break-rewrites(?:=.+)?
    | -M.*
    | --find-renames(?:=.+)?
    | -C.*
    | --find-copies(?:=.+)?
    | --find-copies-harder
    | -D
    | --irreversible-delete
    | -l.+

    | -R

    | -a
    | --text
    | --ignore-space-at-eol
    | -b
    | --ignore-space-change
    | -w
    | --ignore-all-space
    | --ignore-blank-lines

    | --inter-hunk-context=.+
    | -W
    | --function-context

    | --textconv
    | --no-textconv

    | --src-prefix=.*
    | --dst-prefix=.*
    | --no-prefix
    )$
/xs;

# Query the command line of the parent process so we can extract its list of
# diff options.  In doing so, our embedded diff will better match the output
# formatting of its parent, for a more native look.
sub get_git_diff_options {
    my $PPID = getppid();
    my $file = "/proc/$PPID/cmdline";

    local $/;
    open my $fh, '<', $file or die "Cannot open “$file”: $!";
    my @args = split m/\0/, <$fh>;
    close $fh or warn "Cannot close “$file”: $!";

    return grep { $_ =~ &DIFF_OPTS } @args;
}

sub print_help {
    print <<HELP;
Setup: git config diff.<driver>.command '$0 [OPTIONS] --'
Compare the archived files within tarballs as part of git-diff.
Do NOT call this tool directly; it is designed to be used by Git.

Options:
    --help, -?      Print this message and exit

    --no-overview   Omit entry showing "Tarballs a/ and b/ differ".
    --cache         Use cache for faster lookup of tarball contents.
    --no-cache      Disable cache use (default).
    --cache-ref=<ref>
                    Specify the git-notes ref used to cache the git tree content
                    for a blob.  Implies --cache.  When not given, --cache uses
                    "refs/notes/ext-diff/tarball".

Once configured, this tool can be called as part of normal Git commands.
Usage: git diff [diff-options]
       git show --ext-diff [show-options]
       git log -p --ext-diff [log-options]
       git <command> -p --ext-diff [command-options]

See also: "Generating diff text" in `man 5 gitattributes`.
HELP
}
