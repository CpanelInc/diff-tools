#!/usr/local/cpanel/3rdparty/bin/perl

# Copyright 2020, cPanel, L.L.C.
# All rights reserved.
# http://cpanel.net
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the owner nor the names of its contributors may be
# used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use v5.14;    # For s///r
use strict;
use warnings;

use Archive::Tar         ();
use Getopt::Long         ();
use Git::Raw::Note       ();
use Git::Raw::Repository ();

exit _main(@ARGV) unless caller;

sub _main {
    my @args = @_;

    my %conf = (
        overview               => 1,
        cache_ref              => 'refs/notes/ext-diff/tarball',
        propagate_diff_options => 1,
    );
    Getopt::Long::Parser->new(
        config => [ 'posix_default', 'gnu_compat' ],
    )->getoptionsfromarray(
        \@args,
        'help|?' => \my $print_help,

        'overview!'   => \$conf{overview},
        'cache!'      => \$conf{cache},
        'cache-ref=s' => sub { $conf{cache} = 1; $conf{cache_ref} = "$_[1]" },

        'indent:s' => \$conf{indent},

        'propagate-diff-options!' => \$conf{propagate_diff_options},
        'exclude-diff-option=s@'  => \$conf{exclude_diff_option},
        'prepend-diff-option=s@'  => \$conf{prepend_diff_option},
        'append-diff-option=s@'   => \$conf{append_diff_option},
    );

    if ($print_help) {
        print_help();
        return 0;
    }

    # Performs exec system call, preventing it from returning.
    _execute_diff_for_git( \%conf, @args );
}

sub _execute_diff_for_git {
    my ( $conf, $old_git_path, $old_file, $old_hex, $old_mode, $new_file, $new_hex, $new_mode, $new_git_path, $git_annotations ) = @_;
    $new_git_path //= $old_git_path;

    my $repo = Git::Raw::Repository->discover('.');

    my $old_tree = _extract_files( $conf, $repo, $old_hex, $old_file, $old_git_path );
    my $new_tree = _extract_files( $conf, $repo, $new_hex, $new_file, $new_git_path );

    my @options = get_git_diff_options($conf);
    my %parsed  = parse_git_diff_options(@options);
    ( $old_tree, $new_tree ) = ( $new_tree, $old_tree ) if $parsed{reverse};

    if ( $conf->{overview} ) {
        my $src_prefix = ( map { m/^--src-prefix=(.*)|^--no-prefix()/ ? ($1) : () } @options )[-1] // "a/";
        my $dst_prefix = ( map { m/^--dst-prefix=(.*)|^--no-prefix()/ ? ($1) : () } @options )[-1] // "b/";
        ( $src_prefix, $dst_prefix ) = ( $dst_prefix, $src_prefix ) if $parsed{reverse};

        # Check the last color-related command line option or git-config.
        my $no_color;
        if ( my $last_color_option = ( grep { m/^--(?:no-)?color/ } @options )[-1] ) {
            $no_color = $last_color_option =~ m/--no-color|--color=never/;
        }
        else {
            $no_color = system qw(git config --get-colorbool color.diff);    # Will check for TTY
        }
        my $header_color = $no_color ? '' : qx{git config --get-color color.diff.meta bold};

        my $prefix = $parsed{line_prefix} // '';
        print_header( "diff --git $src_prefix$old_git_path $dst_prefix$new_git_path", $header_color, $prefix );
        print_header( $git_annotations =~ s/^\Q$prefix\E//mgr,                        $header_color, $prefix ) if $git_annotations;
        print "${prefix}Tarballs $src_prefix$old_git_path and $dst_prefix$new_git_path differ\n";
    }

    amend_git_diff_options( $conf, \@options, \%parsed );
    exec 'git', 'diff', $old_tree, $new_tree, @options;
    die "Cannot exec: $!";
}

sub print_header {
    my ( $data, $color, $prefix ) = @_;

    foreach ( split m/\n/, $data ) {
        print $prefix if length $prefix;
        print $color  if $color;
        print $_;
        print "\e[m" if $color;
        print "\n";
    }

    return;
}

sub _extract_files {
    my ( $conf, $repo, $id, $tar_file, $git_path ) = @_;
    my $cache_ref = $conf->{cache} ? $conf->{cache_ref} : undef;

    my $message;
    if ( $id ne '0' x 40 && $id ne '.' && $cache_ref ) {
        my $note = Git::Raw::Note->read( $repo, $id, $cache_ref );
        $message = $note ? $note->message() : '';
        foreach my $line ( split m/\0/, $message ) {
            my ( $tree, $path ) = split m/ /, $line, 2;
            if ( $path eq $git_path ) {
                return $tree if defined $repo->lookup($tree);

                # Remove the cached entry so it can be replaced with the newly
                # calculated tree.  Since we already need to re-build the tree,
                # there is little cost to update the entry.  And this allows
                # the algorithm to change, since the cache won't be permanent.
                # However, to force a refresh, the dangling tree needs to be
                # pruned with git-gc.
                $message =~ s/(?<=\0)\Q$tree\E [^\0]\0//;
                last;
            }
        }
    }

    # Get a clean index, in memory; modifications to this object will not alter
    # the Git repository because we never write the index to disk.
    my $index = $repo->index();
    $index->clear();

    # Add files to index
    my $iter = Archive::Tar->iter($tar_file);
    while ( my $f = $iter->() ) {
        _handle_file( $index, $f, $git_path );
    }

    # Create root tree
    my $tree = $index->write_tree();

    # Store tree information into note for caching.  We must include the path
    # because the tree will differ based on the path of the tarball and the
    # tarball can be moved or renamed.
    if ( defined $message ) {
        $message .= "$tree $git_path\0";
        Git::Raw::Note->create( $repo, $id, $message, $cache_ref, 1 );
    }

    return $tree;
}

sub _handle_file {
    my ( $index, $file, $git_path ) = @_;

    my $full_path = $git_path . '/' . $file->full_path;
    if ( $file->type eq '0' ) {
        my $mode = $file->mode & 0100 ? 0100755 : 0100644;
        $index->add_frombuffer( $full_path, $file->get_content_by_ref, $mode );
    }
    elsif ( $file->type eq '2' ) {
        $index->add_frombuffer( $full_path, $file->linkname, 0120000 );
    }
    elsif ( $file->type ne '5' ) {
        die "Unrecognized type: " . $file->type;
    }

    return;
}

sub get_arguments_from_proc {
    my ($pid) = @_;
    my $file = "/proc/$pid/cmdline";

    local $/;
    open my $fh, '<', $file or die "Cannot open “$file”: $!";
    my @args = split m/\0/, <$fh>;
    close $fh or warn "Cannot close “$file”: $!";

    return @args;
}

# The git-diff options we will propagate.
#
# Some options may be difficult to implement in a well integrated way, and so
# they are excluded (for now).  For example, `-p --raw`, displays all the raw
# output before the diff; to propagate `--raw`, we would have a nested entry
# where raw output suddenly reappears and could cause integration problems.
# The same is true with the `--*stat` family of options.
#
# See https://git-scm.com/docs/diff-options for list of available options.
use constant { NO_VALUE => 0, OPTIONAL_VALUE => 1, REQUIRE_VALUE => 2 };
use constant DIFF_SHORT_OPTS => {
    p => &NO_VALUE,         # Implied
    u => &NO_VALUE,         # Implied
    s => undef,             # This tool would not run if this option is given [NO_VALUE]
    U => &REQUIRE_VALUE,
    X => undef,             # See --stat [OPTIONAL_VALUE]
    z => undef,             # Useless, given the arguments we accept [NO_VALUE]
    B => &OPTIONAL_VALUE,
    M => &OPTIONAL_VALUE,
    C => &OPTIONAL_VALUE,
    D => &NO_VALUE,
    l => &REQUIRE_VALUE,
    S => undef,             # Parent must select us for search [REQUIRE_VALUE]
    G => undef,             # Parent must select us for search [REQUIRE_VALUE]
    O => &REQUIRE_VALUE,
    R => &NO_VALUE,
    a => &NO_VALUE,
    b => &NO_VALUE,
    w => &NO_VALUE,
    W => &NO_VALUE,
};
use constant DIFF_LONG_OPTS => {
    '--patch'    => &NO_VALUE,         # Implied
    '--no-patch' => undef,             # This tool would not be run if this option is given [NO_VALUE]
    '--unified'  => &OPTIONAL_VALUE,
    '--output'   => undef,             # This will lead to processes overwriting each other; ignore for now [REQUIRE_VALUE]

    '--raw'            => undef,       # This tool would not be run if this option is given without -p [NO_VALUE]
    '--patch-with-raw' => undef,       # This would inject raw output into the middle of a patch [NO_VALUE]

    '--output-indicator-new'     => &REQUIRE_VALUE,
    '--output-indicator-old'     => &REQUIRE_VALUE,
    '--output-indicator-context' => &REQUIRE_VALUE,

    '--indent-heuristic'    => &NO_VALUE,
    '--no-indent-heuristic' => &NO_VALUE,

    '--minimal'        => &NO_VALUE,
    '--patience'       => &NO_VALUE,
    '--histogram'      => &NO_VALUE,
    '--anchored'       => &REQUIRE_VALUE,
    '--diff-algorithm' => &REQUIRE_VALUE,

    # These would inject stat output into the middle of a patch
    '--stat'            => undef,    # OPTIONAL_VALUE
    '--stat-width'      => undef,    # REQUIRE_VALUE
    '--stat-name-width' => undef,    # REQUIRE_VALUE
    '--stat-count'      => undef,    # REQUIRE_VALUE
    '--compact-summary' => undef,    # NO_VALUE
    '--numstat'         => undef,    # NO_VALUE
    '--shortstat'       => undef,    # NO_VALUE
    '--dirstat'         => undef,    # OPTIONAL_VALUE
    '--cumulative'      => undef,    # NO_VALUE
    '--dirstat-by-file' => undef,    # OPTIONAL_VALUE
    '--summary'         => undef,    # NO_VALUE
    '--patch-with-stat' => undef,    # NO_VALUE

    '--name-only'   => undef,        # This tool would not run if this option is given [NO_VALUE]
    '--name-status' => undef,        # This tool would not run if this option is given [NO_VALUE]
    '--submodule'   => undef,        # Tarballs cannot contain submodules [OPTIONAL_VALUE]

    '--color'           => &OPTIONAL_VALUE,
    '--no-color'        => &NO_VALUE,
    '--color-moved'     => &OPTIONAL_VALUE,
    '--no-color-moved'  => &NO_VALUE,
    '--color-moved-ws'  => &REQUIRE_VALUE,
    '--word-diff'       => &OPTIONAL_VALUE,
    '--word-diff-regex' => &REQUIRE_VALUE,
    '--color-words'     => &OPTIONAL_VALUE,

    '--no-renames'      => &NO_VALUE,
    '--rename-empty'    => &NO_VALUE,
    '--no-rename-empty' => &NO_VALUE,

    '--check'              => &NO_VALUE,
    '--ws-error-highlight' => &REQUIRE_VALUE,

    '--full-index' => &NO_VALUE,
    '--binary'     => &NO_VALUE,
    '--abbrev'     => &OPTIONAL_VALUE,

    '--break-rewrites'      => &OPTIONAL_VALUE,
    '--find-renames'        => &OPTIONAL_VALUE,
    '--find-copies'         => &OPTIONAL_VALUE,
    '--find-copies-harder'  => &NO_VALUE,
    '--irreversible-delete' => &NO_VALUE,

    '--diff-filter'   => undef,    # If the source tarball doesn't match the filter, then nothing is shown, even if it would match [REQUIRE_VALUE]
    '--find-object'   => undef,    # Git will not search via an external diff [REQUIRE_VALUE]
    '--pickaxe-all'   => undef,    # Git will not search via an external diff [NO_VALUE]
    '--pickaxe-regex' => undef,    # Git will not search via an external diff [NO_VALUE]

    '--relative'    => undef,      # Handled by parent diff [OPTIONAL_VALUE]
    '--no-relative' => &NO_VALUE,

    '--text'                => &NO_VALUE,
    '--ignore-cr-at-eol'    => &NO_VALUE,
    '--ignore-space-at-eol' => &NO_VALUE,
    '--ignore-space-change' => &NO_VALUE,
    '--ignore-all-space'    => &NO_VALUE,
    '--ignore-blank-lines'  => &NO_VALUE,

    '--inter-hunk-context' => &REQUIRE_VALUE,
    '--function-context'   => &NO_VALUE,

    # Handled by parent diff.  If we did accept this, we would (almost) always
    # exit non-zero, which the parent diff would interpret as an error, causing
    # it to abort.
    '--exit-code' => undef,    # NO_VALUE
    '--quiet'     => undef,    # NO_VALUE

    '--ext-diff'    => &NO_VALUE,    # Implied on git-diff.  Since we use git-diff, nested ext-diff will occur.
    '--no-ext-diff' => undef,        # This tool would not run if this option is given [NO_VALUE]
    '--textconv'    => &NO_VALUE,
    '--no-textconv' => &NO_VALUE,

    '--ignore-submodules' => undef,    # Tarballs cannot contain submodules [OPTIONAL_VALUE]

    '--src-prefix'  => &REQUIRE_VALUE,
    '--dst-prefix'  => &REQUIRE_VALUE,
    '--no-prefix'   => &NO_VALUE,
    '--line-prefix' => &REQUIRE_VALUE,

    '--ita-invisible-in-index' => undef,    # "git add -N" cannot occur [NO_VALUE]
};

sub collect_allowed_options {
    my ( $short_opts, $long_opts, $args ) = @_;

    my @options;
    while (@$args) {
        my $arg = shift @$args;
        next if substr( $arg, 0, 1 ) ne '-';
        if ( substr( $arg, 1, 1 ) ne '-' ) {
            my $chars = substr $arg, 1;
            while ( length $chars ) {
                my $char = substr $chars, 0, 1;
                if ( $short_opts->{$char} ) {    # If it can have a value
                    push @options, "-$chars";
                    push @options, shift(@$args) if length($chars) == 1 && $short_opts->{$char} == &REQUIRE_VALUE;
                    last;                        # Since a value can follow, this must be the last option
                }
                elsif ( defined $short_opts->{$char} ) {
                    push @options, "-$char";
                }
                $chars = substr $chars, 1;
            }
        }
        else {
            my $index = index $arg, '=';
            my $key = $index == -1 ? $arg : substr( $arg, 0, $index );
            if ( defined $long_opts->{$key} ) {
                push @options, $arg;
                push @options, shift(@$args) if $long_opts->{$key} == &REQUIRE_VALUE && $index == -1;
            }
        }
    }

    return @options;
}

# Query the command line of the parent process so we can extract its list of
# diff options.  In doing so, our embedded diff will better match the output
# formatting of its parent, for a more native look.
sub get_git_diff_options {
    my ($conf) = @_;
    return if !$conf->{propagate_diff_options};

    my $diff_short_opts = &DIFF_SHORT_OPTS;
    my $diff_long_opts  = &DIFF_LONG_OPTS;
    if ( $conf->{exclude_diff_option} ) {
        foreach my $exclude ( @{ $conf->{exclude_diff_option} } ) {
            die "Value to --exclude-diff-option= must begin with a dash: $exclude\n" if substr( $exclude, 0, 1 ) ne '-';
            if ( substr( $exclude, 1, 1 ) ne '-' ) {
                my @chars = split m//, substr( $exclude, 1 );
                delete $diff_short_opts->{$_} foreach (@chars);
            }
            else {
                delete $diff_long_opts->{$exclude};
            }
        }
    }

    my @args = get_arguments_from_proc(getppid);
    return collect_allowed_options( $diff_short_opts, $diff_long_opts, \@args );
}

sub amend_git_diff_options {
    my ( $conf, $opts, $values ) = @_;

    if ( $conf->{prepend_diff_option} ) {
        unshift @$opts, @{ $conf->{prepend_diff_option} };
    }
    if ( $conf->{append_diff_option} ) {
        push @$opts, @{ $conf->{append_diff_option} };
    }

    if ( defined $conf->{indent} ) {
        push @$opts, sprintf "--line-prefix=%s%s", $values->{line_prefix} // '', length $conf->{indent} ? $conf->{indent} : "\t";
    }

    return;
}

# Some values we must actively parse, in addition to passing them through.
sub parse_git_diff_options {
    my %values;
    Getopt::Long::Parser->new(
        config => [ 'posix_default', 'gnu_compat', 'permute', 'bundling', 'pass_through' ],
    )->getoptionsfromarray(
        [@_],
        'R'             => \$values{reverse},
        'line-prefix=s' => \$values{line_prefix},
    );

    return %values;
}

sub print_help {
    print <<HELP;
Setup: git config diff.<driver>.command '$0 [OPTIONS] --'
Compare the archived files within tarballs as part of git-diff.
Do NOT call this tool directly; it is designed to be used by Git.

Options:
    --help, -?      Print this message and exit

    --no-overview   Omit entry showing "Tarballs a/ and b/ differ".
    --cache         Use cache for faster lookup of tarball contents.
    --no-cache      Disable cache use (default).
    --cache-ref=<ref>
                    Specify the git-notes ref used to cache the git tree content
                    for a blob.  Implies --cache.  When not given, --cache uses
                    "refs/notes/ext-diff/tarball".
    --indent[=<prefix>]
                    When displaying the diff of tarball contents, prefix each
                    line with <prefix>.  The overview is not indented.  If not
                    given, TAB is used for <prefix>.
    --no-propagate-diff-options
                    Disable propagation of diff options from parent process.
    --exclude-diff-option=<option>
                    Prevent the given option from being propagated to this
                    tool's diff creator.  This can disable unwanted processing,
                    e.g. --exclude-diff-option=--check.  Can be given multiple
                    times.
    --prepend-diff-option=<option>
                    Specify an option to put before the propagated ones; useful
                    for setting default behavior that can be overturned.  Can
                    be given multiple times.
    --append-diff-option=<option>
                    Specify an option to put after the propagated ones. Can be
                    given multiple times.

Diff Option Propagation
    To seamlessly integrate with Git's diff output, this tool reads the diff
    options passed to the Git command (the one that transparently calls this
    tool).  Supported options are re-used in the diff this tool creates.
    See "git help diff" for a list of diff options; not all are propagated.

Once configured, this tool can be called as part of normal Git commands.
Usage: git diff [diff-options]
       git show --ext-diff [show-options]
       git log -p --ext-diff [log-options]
       git <command> -p --ext-diff [command-options]

See also: "Generating diff text" in `man 5 gitattributes`.
HELP
}
